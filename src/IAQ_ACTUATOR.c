/***********************************************************************************************************************
* DISCLAIMER
* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products.
* No other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
* applicable laws, including copyright laws. 
* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING THIS SOFTWARE, WHETHER EXPRESS, IMPLIED
* OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NON-INFRINGEMENT.  ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED.TO THE MAXIMUM EXTENT PERMITTED NOT PROHIBITED BY
* LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES SHALL BE LIABLE FOR ANY DIRECT,
* INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS SOFTWARE, EVEN IF RENESAS OR
* ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability 
* of this software. By using this software, you agree to the additional terms and conditions found by accessing the 
* following link:
* http://www.renesas.com/disclaimer
*
* Copyright (C) 2020 Renesas Electronics Corporation. All rights reserved.
***********************************************************************************************************************/

/***********************************************************************************************************************
*  File Name    : ACTUATION_TRAINING.c
*  Description  : Main Program
*  Creation Date: 2023-02-16
*  This file was generated by Smart Configurator.
***********************************************************************************************************************/
#include "main.h"

/* Display area data*/
static ST7735S_display_area_info_t disp_info;
/* Hardware event flags & buffer variable*/
volatile hardware_event_t hw_event_flags = NO_EVENT;
volatile hardware_event_t hw_event_flags_copy = NO_EVENT;
/* rotary counter*/
volatile int16_t rotary_count;

/** @brief Tones to be used by the DTC*/
uint8_t tones[MAXIMUM_SYSTEM_STATES][9] = {
		{0x8FU, 0x8FU, 0x8EU, 0x8EU, 0x8DU, 0x8DU, 0x8CU, 0x8CU, 0x00U},
		{0x8CU, 0x8CU, 0x8DU, 0x8DU, 0x8EU, 0x8EU, 0x8FU, 0x8FU, 0x00U},
		{0x8CU, 0x8DU, 0x8EU, 0x8FU, 0x8CU, 0x8DU, 0x8EU, 0x8FU, 0x00U},
};

void main(void)
{
	/****************************************************************************************
	 *  Initialisation																		*
	 ***************************************************************************************/
	EI();

	/* Call necessary configurator start API's*/
	R_Config_TAU0_0_Start();
	R_Config_TAU0_1_Start();
	R_Config_TAU0_3_Start();
	R_Config_CSI00_Start_app();

	/* Initialise the ELCL*/
	Elcl_set_input(&elcl_ctl, ELCL_INPUT_4, ELCL_SRC_PIN1_611_INTC5);
	Elcl_set_input(&elcl_ctl, ELCL_INPUT_6, ELCL_SRC_P51);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_2, ELCL_INPUT_REG_4, ELCL_INVERTED_LOGIC);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_6, ELCL_INPUT_REG_6, ELCL_INVERTED_LOGIC);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_0, ELCL_INPUT_REG_4, ELCL_INVERTED_LOGIC);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_1, ELCL_INPUT_REG_6, ELCL_INVERTED_LOGIC);
	Elcl_set_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_ENABLE_FLIPFLOP0);
	Elcl_set_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_EXOR_CELL_0);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_2, ELCL_FLIP_FLOP0_INPUT);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_6, ELCL_FLIP_FLOP0_CLK);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_0, ELCL_CELL0_INPUT_0);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK1, ELCL_LNK_1, ELCL_CELL0_INPUT_1);

	Elcl_link_input(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_0, ELCL_OUTPUT_FLIP_FLOP0_L1, ELCL_INVERTED_LOGIC);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_1, ELCL_OUTPUT_FLIP_FLOP0_L1, ELCL_POSITIVE_LOGIC);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_2, ELCL_OUTPUT_CELL0_L1, ELCL_INVERTED_LOGIC);
	Elcl_link_input(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_3, ELCL_OUTPUT_CELL0_L1, ELCL_INVERTED_LOGIC);
	Elcl_set_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_AND_CELL_0);
	Elcl_set_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_AND_CELL_1);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_0, ELCL_CELL0_INPUT_0);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_2, ELCL_CELL0_INPUT_1);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_1, ELCL_CELL1_INPUT_0);
	Elcl_link_to_logic(&elcl_ctl, ELCL_BLOCK2, ELCL_LNK_3, ELCL_CELL1_INPUT_1);

	Elcl_set_output(&elcl_ctl, ELCL_OUTPUT_3, ELCL_OUTPUT_L2_CELL0, ELCL_POSITIVE_LOGIC);
	Elcl_set_output(&elcl_ctl, ELCL_OUTPUT_4, ELCL_OUTPUT_L2_CELL1, ELCL_POSITIVE_LOGIC);
	Elcl_set_output_state(&elcl_ctl, ELCL_OUTPUT_3, ELCL_OUTPUT_ENABLED);
	Elcl_set_output_state(&elcl_ctl, ELCL_OUTPUT_4, ELCL_OUTPUT_ENABLED);

	/* Initialise the display driver*/
	St7735s_init(COLOUR_WHITE);
	St7735s_get_display_area_info(&disp_info);
	Text_init(disp_info.xmax, disp_info.ymax);
	Text_set_font(&default_font);
	St7735s_wake_display();
	St7735s_display_on();
	CCDE |= 0x40U;
	CCS6 = 0x04U; /* 15mA backlight*/

	/* Write default text*/
	Text_put_line(TEXT_X_POSITION, TEXT_Y_POSITION, "1", COLOUR_BLACK, COLOUR_WHITE);

	/****************************************************************************************
	 *  Main loop																			*
	 ***************************************************************************************/
	while(1)
	{
		static int16_t system_output_state = 1;

		DI();
		hw_event_flags_copy = hw_event_flags;
		hw_event_flags &= ~hw_event_flags_copy; /* Clear the events which have been detected*/
		EI();

		if(HW_EVENT_OCCURRED(hw_event_flags_copy, BUTTON_CLICK))
		{
			CCS0 = (system_output_state % MAXIMUM_SYSTEM_STATES) + 1;
			CCDE |= 0x03U; /* Turn on LED's*/

			if((system_output_state > 0) && (system_output_state <= MAXIMUM_SYSTEM_STATES))
			{
				Start_dtc((__near uint8_t *)&tones[system_output_state-1]);
				Start_timer_wfi();
			}
		}

		if(HW_EVENT_OCCURRED(hw_event_flags_copy, ROTARY_COUNT_UPDATED))
		{
			static char l_str[16] = {0,};

			DI();
			int16_t l_rot_count = rotary_count % MAXIMUM_SYSTEM_STATES; /* Apply maximum range on rotary count*/
			rotary_count = 0;
			EI();

			if((system_output_state + l_rot_count) <= 0)
			{
				system_output_state = MAXIMUM_SYSTEM_STATES + 1;
			}
			else if((system_output_state + l_rot_count) > MAXIMUM_SYSTEM_STATES)
			{
				system_output_state = 0;
			}
			else
			{
				/* Do Nothing*/
			}

			system_output_state += l_rot_count;

			(void)Text_int_to_str(system_output_state, l_str);

			/* Erase previous text*/
			Text_put_line(TEXT_X_POSITION, TEXT_Y_POSITION, "  ", COLOUR_BLACK, COLOUR_WHITE);

			/* Write new text*/
			Text_put_line(TEXT_X_POSITION, TEXT_Y_POSITION, l_str, COLOUR_BLACK, COLOUR_WHITE);
		}
	}
}
/* END OF MAIN*/
